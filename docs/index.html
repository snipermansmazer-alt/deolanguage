<!DOCTYPE html>
<html lang="la-x-liturgica">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lingua Deonic — Translator</title>
<style>
  :root{
    --bg:#f9f8f6; --ink:#1e1b16; --panel:#f1ede5; --accent:#d3c8a6; --accent-2:#c5b88e;
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    --serif: "Garamond", "Times New Roman", serif;
  }
  body{font-family:var(--serif); background:var(--bg); color:var(--ink); padding:2rem; line-height:1.6;}
  h1{ text-align:center; font-variant:small-caps; margin-top:0; }
  #translatorBox{ max-width:900px; margin:0 auto; text-align:center; }
  textarea{ width:95%; height:220px; font-size:1.05rem; border-radius:10px; border:1px solid #b5a97f;
            padding:12px; resize:vertical; background:#fffaf3; }
  button{ padding:10px 20px; font-size:1.05rem; border-radius:10px; border:none;
          background:var(--accent); cursor:pointer; margin:10px 6px 0; }
  button:hover{ background:var(--accent-2); }
  .panel{ margin:22px auto 0; text-align:left; background:var(--panel); padding:16px; border-radius:12px; }
  #output, #meta { white-space:pre-wrap; }
  .mono{ font-family:var(--mono); font-size:.95rem; }
  details{ margin-top:10px; }
  summary{ cursor:pointer; }
  .badge{ display:inline-block; padding:.1rem .5rem; border-radius:999px; background:#e8e1cf; margin-left:.35rem; font-size:.8rem; }
</style>
</head>
<body>

<h1>Lingua Deonic — Translator</h1>

<div id="translatorBox">
  <textarea id="inputWord" placeholder="Paste a chapter or whole book and press Translate…"></textarea><br/>
  <button id="translateBtn">Translate</button>
  <button id="copyBtn" title="Copy Deonic translation">Copy</button>

  <div id="output" class="panel mono"></div>
  <div id="meta" class="panel mono"></div>

  <details class="panel">
    <summary>Show dictionary hit/miss stats <span id="statsBadge" class="badge">ready</span></summary>
    <div id="stats" class="mono"></div>
  </details>
</div>

<script>
// =========================
// CORE DICTIONARY & SACRED SET
// =========================
const sacred = new Set([
  "deo","craigus","luesium","initum","initum-terra","obscurus-silva","yekumalesh","wonderium","coelum","mori"
]);

const dictionary = {
  "a":"unon","the":"ilion","of":"de","and":"et","for":"pro","on":"super","in":"intra","at":"ad","to":"ad","by":"per","from":"ex","with":"cum","into":"intro",
  "was":"erat","were":"erant","been":"fuit","being":"esseon","had":"habuit","has":"habet","is":"est","are":"sunt","be":"esse",
  "that":"quod","those":"illos","these":"illos","this":"hic","not":"non","no":"non","but":"sed","then":"tunc","if":"si","so":"ita","because":"quia","as":"ut","do":"facere","did":"fecit","done":"factum","made":"feceron",
  "book":"liber","world":"mundus","earth":"terra","heaven":"caelum","man":"hominon","human":"homo","humanity":"humanitasion",
  "dragon":"draco","spirit":"spiritus","demon":"daemon","angel":"angelion","sword":"gladion","iron":"ferrum","fire":"ignis","light":"lux","dark":"obscurion",
  "food":"cibus","blood":"sanguion","flesh":"caro","faith":"fidelis","salvation":"salvation","creation":"initum","craig":"craigus","deo":"deo"
};

// =========================
// SMART AUTO-DEONICIZATION
// =========================
function isSacredWord(w){ return sacred.has(w.toLowerCase()); }

function matchCasing(base, original){
  if (original.toUpperCase() === original) return base.toUpperCase();
  if (original[0] && original[0] === original[0].toUpperCase())
    return base.charAt(0).toUpperCase()+base.slice(1);
  return base;
}

function deonicizeUnknown(w){
  const low = w.toLowerCase();
  if (isSacredWord(low)) return w;
  if (/^\d+([.,:/-]\d+)*$/.test(low)) return w;

  let stem = low.replace(/^un-/, "in-").replace(/^re-/, "re-");

  // Plural patterns
  if (/ies$/.test(stem)) return stem.replace(/ies$/, "ionae");
  if (/ves$/.test(stem)) return stem.replace(/ves$/, "ae");
  if (/xes$|ches$|shes$|sses$|zes$/.test(stem)) return stem.replace(/es$/, "ae");
  if (/s$/.test(stem) && !/ss$/.test(stem)) return stem.replace(/s$/, "ae");

  // Verb patterns
  if (/ied$/.test(stem)) return stem.replace(/ied$/, "ium");
  if (/ed$/.test(stem)) return stem.replace(/ed$/, "um");
  if (/ing$/.test(stem)) return stem.replace(/ing$/, "erion");

  // Adjective / adverb roots
  if (/ly$/.test(stem)) return stem.replace(/ly$/, "lither");
  if (/ness$/.test(stem)) return stem.replace(/ness$/, "tudo");
  if (/ment$/.test(stem)) return stem.replace(/ment$/, "mentum");
  if (/tion$/.test(stem)) return stem.replace(/tion$/, "tio");
  if (/sion$/.test(stem)) return stem.replace(/sion$/, "sio");
  if (/ship$/.test(stem)) return stem.replace(/ship$/, "atus");
  if (/est$/.test(stem)) return stem.replace(/est$/, "issim");
  if (/er$/.test(stem)) return stem.replace(/er$/, "ior");

  // Determine likely word type heuristically
  const isVerb = /e$|ate$|ify$|ise$|ize$|ing$|ed$/.test(stem);
  const isAdj  = /ful$|less$|ous$|ive$|al$|ic$|ant$|ent$|ary$/.test(stem);
  const isNoun = /tion$|ment$|ness$|dom$|hood$|ship$|ity$/.test(stem);

  let ending = "on";
  if (isVerb) {
    const verbEndings = ["on","um","erion","areon","eron","arion","uron"];
    ending = verbEndings[Math.floor(Math.random()*verbEndings.length)];
  } else if (isAdj) {
    const adjEndings = ["alis","ior","ar","en","eus","ilis","or"];
    ending = adjEndings[Math.floor(Math.random()*adjEndings.length)];
  } else if (isNoun) {
    const nounEndings = ["on","um","is","ae","or","en","ion","amentum"];
    ending = nounEndings[Math.floor(Math.random()*nounEndings.length)];
  } else {
    const generic = ["on","um","is","ae","or","en","ion","ar","al"];
    ending = generic[Math.floor(Math.random()*generic.length)];
  }

  // Avoid vowel collisions
  if (/[aeiou]$/.test(stem) && /^[aeiou]/.test(ending)) ending = ending.slice(1);

  return stem + ending;
}

// =========================
// CONTROLLER / UI
// =========================
document.getElementById("translateBtn").addEventListener("click", translateText);
document.getElementById("copyBtn").addEventListener("click", copyOutput);

function tokenizeWithDelims(str){
  return str.match(/[A-Za-z]+|\d+|[^A-Za-z\d]+/g) || [];
}

function translateChunk(token, seenAuto, seenDict){
  if (!/[A-Za-z]/.test(token)) return token;
  const low = token.toLowerCase();
  if (isSacredWord(low)) return matchCasing(low, token);
  if (dictionary.hasOwnProperty(low)) {
    seenDict.add(low);
    return matchCasing(dictionary[low], token);
  }
  const deon = deonicizeUnknown(token);
  seenAuto.add(low);
  return matchCasing(deon, token);
}

function translateText(){
  const input = document.getElementById("inputWord").value || "";
  const outEl  = document.getElementById("output");
  const metaEl = document.getElementById("meta");
  const statsEl = document.getElementById("stats");
  const statsBadge = document.getElementById("statsBadge");

  if (!input.trim()){
    outEl.textContent = "Please enter or paste text to translate.";
    metaEl.textContent = "";
    statsEl.textContent = "";
    statsBadge.textContent = "empty";
    return;
  }

  const tokens = tokenizeWithDelims(input);
  const seenAuto = new Set();
  const seenDict = new Set();

  const translated = tokens.map(t => translateChunk(t, seenAuto, seenDict)).join("");

  outEl.textContent =
`Deonic Translation:
${translated}`;

  const autoCount = seenAuto.size;
  const dictCount = seenDict.size;
  const totalWords = (input.match(/[A-Za-z]+/g) || []).length;

  metaEl.textContent =
`Summary:
- Total tokens (word-like): ${totalWords}
- Dictionary hits: ${dictCount}
- Auto-Deonicized: ${autoCount}
- Sacred preserved: ${[...sacred].join(", ")}`;

  statsEl.textContent =
`Dictionary hits (first 100): 
${truncateList([...seenDict].sort(), 100).join(", ")}

Auto-Deonicized words (first 100):
${truncateList([...seenAuto].sort(), 100).join(", ")}`;

  statsBadge.textContent = `${dictCount} dict · ${autoCount} auto`;
}

function truncateList(arr, n){
  if (arr.length <= n) return arr;
  return arr.slice(0,n).concat([`…(+${arr.length-n})`]);
}

function copyOutput(){
  const outEl = document.getElementById("output");
  const text = outEl.textContent || "";
  if (!text.trim()) return;
  navigator.clipboard.writeText(text).then(()=> {
    alert("Deonic translation copied to clipboard.");
  });
}
</script>
</body>
</html>
